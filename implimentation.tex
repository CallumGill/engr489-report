
\chapter{Implementation}
For the implementation of this project we decided to implement a agile methodology approach similar to other projects run at  Haunt. The main process model that we will be taking much of the development process from are aspects of SCRUM. The development was split into multiple sprints, with each containing a requirements gathering stage, development and reflection stage. Each sprint will start with a client meeting with Haunt where we will populate the backlog and develop user stories as requirement gathering. Later on in the development we planned to include meetings with potential users and experts for feedback on the implemented solutions and gather more insight for more efficient user stories. However due to unforeseen circumstances we were only able to gather expert feedback within the final sprint. One of the key features of lean and agile methodology is saving on waste. To try and implement this we will focus on building the core product/prototype first and then gain feedback on the product via user testing to gather more specific features and requirements for the product.

\section{Initial Product}
At the start of the project Haunt had a preliminary proof of concept that needed to be further developed. This initial product contained an API that could add cards, decks and users. The front end consisted a simple view that could display the contents of the decks and cards related to the user. The API was developed in Ruby and followed the RESTful architecture, with the front end developed in JavaScript with Redux js for front end state control. All authorization was done through Auth0 as a temporary solution.

\section{Pre-Development}
Before initial development started we first needed to establish what aspect of the product we would be focusing on. Initially the plan was to develop a potential dashboard for the product. However because development on the main product prototype was no longer in progress via Haunt, this project changed focus to general development of the product.
During the first meetings with the product owner, Rob McGrail, Technical Director at Haunt, we established that some of the underlying technologies on both the front end and api side were either excessive or not long term solutions and needed to be removed. These were identified as state control via redux and the authentication system through Auth0, the first sprint was focused on removing these required technologies to reduce future development time. The later sprints would be focused on refining, adding and fleshing out features in the product.

\section{Sprint 1}
As stated above the first sprint was focused on reducing the overhead of future development by removing unnecessary and excessive factors of the  initial proof of concept, namely the authorization system Auth0 and the front end state management control redux js. The product owner and I deemed this an important step to reduce waste at later stages of development and not build up technical overhead.

\subsection{Auth0}
Auth0 is a third party single sign on and token based authentication system that the initial proof of concept was using for user authentication. While this was easy to setup and manage, it was not a suitable long term solution due to extra costs incurred through licensing and extra latency of  relying on a third party service instead of having the authentication handled by the same service as the Restful API. Auth0 would potentially be able to provide better security of data and more complex 
After some consideration we decided it was best to replace the authentication with a JSON web token (JWT) system as it is industry standard for `URL-safe means of representing claims to be transferred between two parties'\cite{jones2015rfc}.

\subsection{JWT Tokens}
JSON web tokens consist of an encrypted token that contains a payload consisting of a JSON object and is encrypted via a JSON web signature. Using these JWT tokens we are able to securely authenticate users and produce a token for them that tells the API their user role, organisation, id and creation date. This allows them to stay logged in securely and helps govern access to the API based on their role.

\subsection{Redux JS}
Redux is a state container for JavaScript applications, it was used to keep the current state of the front end under control to help lower load times and preserve data and scope. Redux is a great tool for managing your app state in a way that allows states to persist through the same session or even through sessions if saved locally. However it comes with some trade offs and requires you to structure your apps data in certain ways:

\begin{itemize}
\item State needs to be described as plain JSON objects and arrays.
\item Describe changes in the system as plain objects
\item Any logic for handling changes to the state needs to be as pure functions
\end{itemize}

These requirements for how you structure logic, state and changes within the system make sense and are often good practices to follow if you wish for your code to be decouple what happened, for example a button press or data finish loading with how this changes things, for example when the data is loaded change the values on screen. However because of the relatively simple states required for this web application and no foreseeable need for a persistent state. It was decided that maintaining the state store through Redux was not required and the app.

So for this sprint the main focus was removing these unnecessary libraries and replace them with current solutions. The Auth0 authentication service was replaced with our own JWT focused authentication using and redux state management was replaced with logic within the components.

\subsection{Summary}
With this sprint focused on removing some of the system that were no longer required a lot of this sprint went into refactoring the code base and implementing the new authentication system. The refactoring of removing redux from the system included moving the action logic for components into the components themselves. This reduced the indirection within the code but more tightly couples the components with the logic and actions of the system. This means that it is harder to implement another component with very similar features that should act the same way but with a different look or display. This was considered a reasonable trade off as it simplifies the workflow of each action and makes the code easier to follow, because the products logic flow should be reasonably simple with no overly complex actions or components.


 \begin{figure}
\includegraphics[width=\textwidth]{s1}
\caption{Display of a fact deck after development in sprint 1}
\centering
\end{figure}

\section{Sprint 2}
This sprint was targeted towards getting some of the key features functional and in a state where the app could be used functionally. The initial proof of concept had some of the features like deck and card creation, user and organisation creation and the ability to view decks/cards linked to your organisation.
